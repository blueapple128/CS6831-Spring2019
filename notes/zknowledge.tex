\section{Zero-Knowledge and Proofs of Knowledge}
\label{sec:zknowledge}
Identity protocols provide proof about the ownership of a private key, without revealing that private key.
We can generalize this notion to proving knowledge of an arbitrary secret without revealing the secret as \emph{zero-knowledge (ZK) proofs}. 
The notion of zero-knowledge was first introduced by Goldwasser et al.~\cite{goldwasser1989knowledge}

For the formal definition of a ZK proof, we follow Boneh-Shoup's treatment~\cite{BonehShoupBook} and define an effective relation as a binary relation $\calR \subseteq \calX \times \calY$  where $\calR, \calX,\calY$ are sets.
(We assume the are efficiently recognizable, meaning one can determine if a value is a member of the set efficiently.)
Elements of $\calY$ are called \emph{statements} and elements of $\calX$ are called \emph{witnesses}.

We can define Sigma protocols, and thus interactive zero-knowledge proofs, relative to relations.

\begin{figure}[h]
\centering

\begin{tikzpicture}
    \node[draw, rectangle] (P) {Prover};
    \node[below=4cm of P] (P2) {};
    \node[right=5cm of P, draw, rectangle] (V) {Verifier};
    \node[below=4cm of V] (V2) {};

    \node[below=1cm of P] (a) {};
    \node[below=1.5cm of V] (b) {};
    \node[below=2cm of V] (c) {};
    \node[below=2.5cm of P] (d) {};
    \node[below=3cm of P] (e) {};
    \node[below=3.5cm of V] (f) {};

    \node[left=0.2cm of a] (genR) { $R \getsr P.com(Y)$ };
    \node[right=0.2cm of c] (genc) { $c \getsr C$ };
    \node[left=0.2cm of e] (genz) { $z \gets P.resp(x,R,c)$ };
    \node[right=0.2cm of f] (verify) { $b \gets V.ver(Y,R,c,z)$ };

    \draw[-] (P) -- (P2);
    \draw[-] (V) -- (V2);

    \draw[->] (a.center) -- (b.center) node [midway, above] {$R$};
    \draw[->] (c.center) -- (d.center) node [midway, above] {$c$};
    \draw[->] (e.center) -- (f.center) node [midway, above] {$z$};

\end{tikzpicture}
\end{figure}

We now generalize the Sigma protocol to prove predicates of the following form.

\begin{equation*}
    \phi(x_1, \dots, x_n) = \left\{ u_1 = \prod_{j=1}^{n} g_{1j}^{x_j} \land \dots \land u_m  = \prod_{j=1}^{n} g_{mj}^{x_j}\right\}
\end{equation*}

Here, $x_1, \dots, x_n$ are the witnesses. The statements are encoded by the $u_j$ and $g_{ij}$ values.
We can then adapt this protocol to different use-cases by adjusting $m$ and $n$. A few examples are listed in the following table.

\begin{tabular}{|c|c|c|}
\hline
    \textbf{Name} & \textbf{Description} & \textbf{Formula} \\
\hline
    Schnorr        & Digital Signatures & $n=1$, $m=1$, $\phi(x) = \left\{ u = g^x \right\}$ \\
    Chaum-Pederson & Prove that a triple X,Y,Z is a DH triple &  $n=1$, $m=2$, $\phi(x) = \left\{ X = g^x \land Z = Y^x\right\}$ \\
    Okamoto        & Prove ``representation'' of dlog &  $n=2$, $m=1$, $\phi(x_1, x_2) = \left\{ u = g^{x_1} h^{x_2} \right\} $ \\
\hline
\end{tabular}

\begin{figure}[h]
\centering

\begin{tikzpicture}
    \node[draw, rectangle, align=center] (P) {\textbf{Prover} \\ (knows $x_1, \dots, x_n$)};
    \node[below=4cm of P] (P2) {};
    \node[right=5cm of P, draw, rectangle, align=center] (V) {\textbf{Verifier} \\ (knows $u_1, \dots, u_m$) };
    \node[below=4cm of V] (V2) {};

    \node[below=1cm of P] (a) {};
    \node[below=1.5cm of V] (b) {};
    \node[below=2cm of V] (c) {};
    \node[below=2.5cm of P] (d) {};
    \node[below=3cm of P] (e) {};
    \node[below=3.5cm of V] (f) {};

    \node[left=0.2cm of a, align=right] (genR) { $r_1, \dots, r_n \getsr Z_q$ \\ $R_i \gets \prod_{j=1}^n g_{ij}^{r_j}$ };
    \node[right=0.2cm of c] (genc) { $c \getsr Z_q$ };
    \node[left=0.2cm of e, align=right] (genz) { $z \gets r_j + x_jc$ \\ for $j=1$ to $n$ };
    \node[right=0.2cm of f, align=center] (verify) { Check that for $i=1$ to $m$\\
    $\prod_{j=1}^{n} g_{ij}^(z_j) = R_i * u_i^c $ };

    \draw[-] (P) -- (P2);
    \draw[-] (V) -- (V2);

    \draw[->] (a.center) -- (b.center) node [midway, above] {$R_1, \dots, R_m$};
    \draw[->] (c.center) -- (d.center) node [midway, label=$c$] {};
    \draw[->] (e.center) -- (f.center) node [midway, label=$z$] {};

\end{tikzpicture}
\end{figure}


\subsection{Properties of Zero-Knowledge Proofs}

\subsection{Non-Interactive Zero-Knowledge Proofs}
\begin{figure}
\centering

\fpage{.25}{
\underline{$\NIZK_{\Phi,\Simu}^\advA$}\\[1pt]
$b \getsr \bits$\\
$b' \getsr \advA^{\ProofOracle}$\\
Return $(b = b')$\medskip

\underline{$\ProofOracle(x,Y)$}\\[1pt]
If $b = 1$ then\\
\myInd $\pi \getsr \Gen(x,Y)$\\
If $b = 0$ then \\
\myInd $\pi \getsr \Simu(Y)$\\
Return $\pi$
}
\fpage{.15}{
\underline{$\NIZK1_{\Phi,\Simu}^\advA$}\\[1pt]
$b \getsr \bits$\\
$b' \getsr \advA^{\ProofOracle,\Horacle}$
Ret $(b = b')$\medskip

\underline{$\ProofOracle(x,Y)$}\\[1pt]
$\pi \getsr \Gen^\Horacle(x,Y)$\\
Ret $\pi$\medskip

\underline{$\Horacle(M)$}\\[1pt]
If $\TabH[M] = \bot$ then\\
\myInd $\TabH[M] \getsr \bits^n$\\
Ret $\TabH[M]$
}
\fpage{.15}{
\underline{$\NIZK0_{\Phi,\Simu}^\advA$}\\[1pt]
$b \getsr \bits$\\
$b' \getsr \advA^{\ProofOracle,\HashSim}$\\
Return $(b = b')$\medskip

\underline{$\ProofOracle(x,Y)$}\\[1pt]
$\pi \getsr \Simu_P(Y)$\\
Return $\pi$\medskip

\underline{$\HashSim(M)$}\\[1pt]
Ret $\Simu_H(M)$
}

\caption{Definition of the Non-Interactive Zero-Knowledge Game}
    \label{fig:nizk}
\end{figure}

So far, we have shown the basic intuition behind showing zero-knowledge in an interactive setting.
Informally speaking in interactive settings the verifier can ask ``questions'' about the proof and gets answers in form of witnesses from the prover.
In an non-interactive setting, the prover has to provide answer to all possible ``questions'' a priori.

Figure \ref{fig:nizk} outlines the basic games for the non-interactive zero-knowledge proof.



